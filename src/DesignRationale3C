Design Rationale:
An exploration of the classes LibrarianTwo, GeminiLibrarian and TalkAction. LibrarianTwo has a unique behaviour of sometimes returning “deadly silence”, and GeminiLibrian calls a external API to create AI generated answers to a user written prompt. These classes are facilitated through the TalkAction class.
The classes align with the Single responsibility principle as each class has a specific purpose as outlined before. This ensures each class has a clear and distinct responsibility. They also adhere to the OCP principle, as this design allows for extension without modification. New types of librarians can be introduced by simply creating additional subclasses that implement the speak () method and providing their own unique behaviour. This avoids modifying existing code and follows OCP. Additionally, it follows DIP rules, by using interfaces like ActionCapable. Higher-level modules (such as TalkAction) depend on abstractions rather than concrete classes. TalkAction can work with any class that implements the ActionCapable interface, making the code more flexible and easier to extend. There is also no repetition which adhere to DRY as Although LibrarianOne, LibrarianTwo, and GeminiLibrarian share the commonality of having a speak() method, they implement their own unique versions of this method. This ensures we aren't repeating logic while allowing for customization where needed. LSP is also followed as all subclasses, such as LibrarianOne, LibrarianTwo, and GeminiLibrarian, can be used interchangeably without affecting the functionality of the program. Each subclass adheres to the same contract by implementing the speak() method, which is expected by the TalkAction class. This maintains consistency and follows LSP.
Furthermore, by encapsulating the internal behaviours of each librarian in their respective classes, it hides the complexity from the outside world. TalkAction doesn't need to know whether it's talking to a static librarian or interacting with an API—it simply calls the speak() method and handles the result. This reduces coupling between classes and makes the system easier to maintain and extend.
Pros:
•	Flexible and Reusable: By abstracting user interactions as actions, new types of actions can easily be added without modifying the overall system. This makes the system modular and open to future extension.
•	Improved Readability: The Action interface provides a common template for all actions, making the code easier to understand. This is because anyone looking at the code can note that every action has an execute() method and a menuDescription() method, which standardizes the way actions are handled.
•	Extensibility: If more complex actions in the future need to be introduced, new classes can be created that implement the Action interface. This allows for more dynamic behaviours without changing the existing codebase, ensuring compliance with OCP.
Cons:
•	Abstractions: The multiple layers of abstraction can interfere with the actual logic flow, which may introduce challenges in debugging or understanding the system.
•	Increased Complexity: All these classes and interfaces might lead to a system where many classes and interfaces are needed to implement even simple functionality. This might increase the learning curve for new developers working on the project.




